name: Tender Hub CI Pipeline

on:
  pull_request:
    types: [ opened, synchronize, reopened, closed ]
    branches: [ main ]

jobs:
  list-and-read:
    runs-on: ubuntu-latest
    outputs:
      terraform_changed: ${{ steps.list-changes.outputs.terraform_changed }}
      python_changes_exist: ${{ steps.list-changes.outputs.python_changes_exist }}

      lambda_create_instance_changed: ${{ steps.list-changes.outputs.lambda_create_instance_changed }}
      lambda_destroy_instance_changed: ${{ steps.list-changes.outputs.lambda_destroy_instance_changed }}
      
      # terraform_version: ${{ steps.read-manifest.outputs.terraform_version }}
      # lambda_create_instance_version: ${{ steps.read-manifest.outputs.lambda_create_instance_version }}
      # lambda_destroy_instance_version: ${{ steps.read-manifest.outputs.lambda_destroy_instance_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: List changes
        id: list-changes
        run: |
          # get list of changed files between branch base and current commit
          # '|| true' protects against error if repo copy is already unshallow
          git fetch --unshallow origin main "${{ github.event.pull_request.base.sha }}" || true
          echo "Fetching latest changes from ${{ github.event.pull_request.base.sha }}" \
            "to compare with current branch..."
          CHANGES="$(git diff --name-only ${{ github.event.pull_request.base.sha }}...HEAD)"

          # extract top-level directories from changed files and get unique list
          CHANGED_DIRS="$(echo "$CHANGES" | grep -o '^[^/]*/' | sort -u)"
          printf "Changes detected in the following directories:\n%s\n" "$CHANGES"

          
          # output key change values for use in later steps
          if echo "$CHANGED_DIRS" | grep -q "infra"; then
            TERRAFORM_CHANGED=true
            echo "Terraform changes detected."
          else
            TERRAFORM_CHANGED=false
            echo "No changes detected to Terraform."
          fi
          
          if echo "$CHANGED_DIRS" | grep -q "src"; then
            PYTHON_CHANGES_EXIST=true
            echo "Changes to Python code detected."
            
            # extract Python files under src/ directory from changed list
            CHANGED_PYTHON="$(echo "$CHANGES" | grep '^src/.*.py | xargs -L 1 basename')

            if echo "$CHANGED_PYTHON" | grep -q "create_budibase_instance.py"; then
              LAMBDA_CREATE_INSTANCE_CHANGED=true
              echo "Lambda function create_budibase_instance changed."
            else
              LAMBDA_CREATE_INSTANCE_CHANGED=false
            fi

            if echo "$CHANGED_PYTHON" | grep -q "destroy_budibase_instance.py"; then
              LAMBDA_DESTROY_INSTANCE_CHANGED=true
              echo "Lambda function destroy_budibase_instance changed."
            else
              LAMBDA_DESTROY_INSTANCE_CHANGED=false
            fi
          else
            PYTHON_CHANGES_EXIST=false
            echo "No changes detected to Python code."
          fi
          
          echo "terraform_changed=$TERRAFORM_CHANGED" >> $GITHUB_OUTPUT
          echo "python_changes_exist=$PYTHON_CHANGES_EXIST" >> $GITHUB_OUTPUT
          echo "lambda_create_instance_changed=$LAMBDA_CREATE_INSTANCE_CHANGED" \
            >> $GITHUB_OUTPUT
          echo "lambda_destroy_instance_changed=$LAMBDA_DESTROY_INSTANCE_CHANGED" \
            >> $GITHUB_OUTPUT

      - name: Fetch base manifest
        id: fetch-manifest
        if: >
          ${{ steps.list-changes.outputs.terraform_changed ||
          steps.list-changes.outputs.python_changes_exist }}
        run:
          MANIFEST_ID="$(git rev-parse --short "${{ github.event.pull_request.base.sha }}")"

          echo "Fetching manifest with id $MANIFEST_ID from S3..."
          aws s3 cp \
            --region "${{ vars.AWS_REGION }}" \
            "s3://${{ vars.MANIFEST_BUCKET }}"/${MANIFEST_ID}.json" \
            manifest.json
          echo "Manifest fetched successfully."

      - name: Upload manifest artefact
        uses: actions/upload-artifact@v4
        with:
          name: base-manifest-${{ github.run_id }}
          path: manifest.json
          if-no-files-found: error
          retention-days: 1
 
  python-test-and-deploy:
    runs-on: ubuntu-latest
    needs: list-and-read
    if: needs.list-and-read.outputs.python_changes_exist == true
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Check linting with ruff
        uses: astral-sh/ruff-action@v3
        with:
          src: >-
            ./src
            ./test

      - name: Check formatting with ruff
        run: ruff format --check

      - name: Run unit tests
        run: pass
      
      - name: Upload changed code to S3
        run: |
          SHORT_SHA="$(git rev-parse --short ${{ github.sha }})"

          if "${{ needs.list-and-read.outputs.lambda_create_instance_changed }}"; then
            mkdir -p packages/lambdas/ && \
            zip src/create_budibase_instance.py packages/lambdas/create_budibase_instance.zip && \
            cp packages/lambdas/create_budibase_instance.zip \
              s3://${{ env.CODE_BUCKET }}/create_budibase_instance/$SHORT_SHA.zip
          fi

          if "$${{ needs.list-and-read.outputs.lambda_destroy_instance_changed }}"; then
            mkdir -p packages/lambdas/ && \
            zip src/destroy_budibase_instance.py packages/lambdas/destroy_budibase_instance.zip && \
            cp src/destroy_budibase_instance.py \
              s3://${{ env.CODE_BUCKET }}/destroy_budibase_instance/$SHORT_SHA.py
          fi

  terraform-test-and-deploy:
    runs-on: ubuntu-latest
    environment: stage
    concurrency:
      group: deploy-to-stage
    permissions: 
      deployments: write
    needs: list-and-read
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          # Ensure unshallow fetch to allow for merge-base checks
          fetch-depth: 0 

      - name: Check for intervening merges
        id: check-merges
        # Check for other merges only if this is a post-merge run
        if: ${{ github.event.pull_request.merged == true }}
        run: |
          TOTAL_REVS=$(git rev-list \
            --count ${{ github.event.pull_request.base.sha }}..${{ github.sha }})
          BRANCH_REVS=$(git rev-list \
            --count ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})

          if [ $TOTAL_REVS -gt $(( $BRANCH_REVS + 1 )) ]; then
            echo "other_merges=true" >> $GITHUB_OUTPUT
          else
            echo "other_merges=false" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        id: configure-aws
        # Continue only if this is a pre-merge run OR post-merge run with other merges
        if: |
          ${{ github.event.pull_request.merged == false ||
          steps.check-merges.outputs.other_merges == 'true' }}
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}

      - name: Set up Terraform
        if: ${{ steps.configure-aws.outcome == 'success' }}
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Download manifest artifact
        id: download-manifest
        uses: actions/download-artifact@v5
        with:
          name: base-manifest-${{ github.run_id }}
          path: manifest.json

      - name: Create Terraform backend and env configuration
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: |
          # Determine Lambda code versions for deployment

          SHORT_SHA="$(git rev-parse --short ${{ github.sha }})"

          if "${{ needs.list-and-read.outputs.lambda_create_instance_changed }}"; then
            LAMBDA_CREATE_SERVICE_VERSION="$SHORT_SHA"
          else
            LAMBDA_CREATE_SERVICE_VERSION="$(
              jq -r '.Latest.Python.create_budibase_instance' manifest.json
            )"
          fi

          if "${{ needs.list-and-read.outputs.lambda_destroy_instance_changed }}"; then
            LAMBDA_DESTROY_SERVICE_VERSION="$SHORT_SHA"
          else
            LAMBDA_DESTROY_SERVICE_VERSION="$(
              jq -r '.Latest.Python.destroy_budibase_instance' manifest.json
            )"
          fi

          # Create backend 
          
          mkdir -p envs/stage
          cat > envs/stage/backend.hcl <<EOF
          region      = "${{ vars.AWS_REGION }}"
          bucket      = "${{ vars.STATE_BUCKET }}"
          key         = "${{ vars.STATE_KEY }}"
          EOF

          cat > envs/stage/terraform.tfvars <<EOF
          ENVIRONMENT = "stage"
          CODE_BUCKET = "${{ vars.CODE_BUCKET }}"

          LAMBDA_CREATE_SERVICE_VERSION  = "$LAMBDA_CREATE_SERVICE_VERSION"
          LAMBDA_DESTROY_SERVICE_VERSION = "$LAMBDA_DESTROY_SERVICE_VERSION" 
          EOF
          
          # Create global .tfvars file
          # For REPO_NAME, sed strips "user-name/repo-name" to just "repo-name"

          cat > global.auto.tfvars <<EOF
          AWS_REGION         = "${{ vars.AWS_REGION }}"
          IAM_USER           = "${{ secrets.IAM_USER }}"
          REPO_NAME          = "$(echo "${{ github.repository }}" | sed -E "s/.+\///g")"
          PREFIX             = "${{ vars.PREFIX }}"
          CLIENT             = "${{ vars.CLIENT }}"
          PROJECT            = "${{ vars.PROJECT }}"
          BUDIBASE_IMAGE_URL = "${{ vars.BUDIBASE_IMAGE_URL }}"
          EOF

      - name: Initialize Terraform
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform init -reconfigure -backend-config="envs/stage/backend.hcl"

      - name: Validate Terraform configuration
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform validate

      - name: Format Terraform code
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform fmt -check

      - name: Use Terraform workspace
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: ./switch_env.sh stage

      - name: Terraform plan with check for changes
        id: terraform-plan
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: |
          set +e
          terraform plan \
            -detailed-exitcode \
            -out=tfplan \
            -var-file="envs/stage/terraform.tfvars" \
            -var="BUDIBASE_TASK_COUNT=1"
          exit_code=$?
          echo "Terraform plan exit code: $exit_code"
          set -e
          if [ $exit_code -eq 2 ]; then
            echo "Changes detected in Terraform configuration."
            echo "runapply=true" >> $GITHUB_OUTPUT
          elif [ $exit_code -eq 1 ]; then
            echo "Error during Terraform plan."
            exit 1
          else
            echo "No changes detected. Infrastructure is up-to-date."
          fi

      - name: Terraform apply
        id: terraform-apply
        working-directory: infra
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: |
          terraform apply tfplan
            echo "lb_url=\"$(terraform output -raw lb_url)\"" >> $GITHUB_OUTPUT

      - name: Clean up Terraform plan file
        working-directory: infra
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: rm -f tfplan

      - name: Post-apply validation
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: |
          echo "Running post-apply validation..."
          
          timeout 300s bash -s "${{ steps.terraform-apply.outputs.lb_url }}" << 'EOF'
            LB_URL="$1"

            start_time="$SECONDS"
            until curl -s "$LB_URL" > /dev/null; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for load balancer to become available at $LB_URL ...$timestamp"
              sleep 10
            done
            echo "Load balancer available at $LB_URL"

            start_time="$SECONDS"
            until curl -s "$LB_URL" | grep -q 'Redirecting to <a href="/builder">/builder</a>'; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for redirection to /builder at $LB_URL ...$timestamp"
              sleep 10
            done
            echo "Redirection to /builder confirmed at $LB_URL"

            start_time="$SECONDS"
            until curl -s "${LB_URL}builder" --compressed | grep title | grep -q Budibase; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for Budibase builder to be available at ${LB_URL}builder ...$timestamp"
              sleep 10
            done
            echo "Budibase builder is available at ${LB_URL}builder"
          EOF

      - name: Terraform destroy
        working-directory: infra
        if: |
          ${{ steps.configure-aws.outcome == 'success' &&
          steps.terraform-plan.outputs.runapply == 'true' && 
          always() }}
        run: terraform destroy -auto-approve -var-file="envs/stage/terraform.tfvars"
      
      - name: Report deployment status to GitHub
        if: success()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Fetch the deployment ID for this commit
          DEPLOYMENT_ID=$(gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/deployments?environment=stage&sha=${{ github.event.pull_request.head.sha}}" \
            --jq '.[0].id')

          if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "null" ]; then
            # Provided deployment ID isn't empty or null, post status "success"
            gh api \
              -X POST \
              -H "Accept: application/vnd.github+json" \
              "repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" \
              -f state='success' \
              -f environment='stage' \
              -f environment_url='https://github.com//${{ github.repository_owner }}/${{ github.repository }}/deployments/stage' \
              -f description='Deployment verified and ready for merge'
          else
            # Deployment ID is empty or null: alert the user and fail
            echo "No deployment found for commit ${{ github.sha }}"
            exit 1
          fi

  update-manifest:
    runs-on: ubuntu-latest
    environment: stage
    needs: [
      list-and-read,
      python-test-and-deploy,
      terraform-test-and-deploy
    ]
    if: ${{ github.event.pull_request.merged == true }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}

      - name: Download manifest artifact
        id: download-manifest
        uses: actions/download-artifact@v5
        with:
          name: base-manifest-${{ github.run_id }}
          path: manifest.json

      - name: Generate and upload manifest
        id: update-manifest
        if: ${{ steps.download-manifest.outcome == 'success' }}
        run: |
          SHORT_SHA="$(git rev-parse --short ${{ github.sha }})"

          if "${{ needs.list-and-read.outputs.terraform_changed }}"; then
            jq '.Latest.Terraform = "'$SHORT_SHA'"' manifest.json \
              > manifest.json.tmp && mv manifest.json.tmp manifest.json
            echo "Updated manifest with new Terraform version: $SHORT_SHA"
          fi

          if "${{ needs.list-and-read.outputs.lambda_create_instance_changed }}"; then
            jq '.Latest.Python.create_budibase_instance = "'$SHORT_SHA'"' manifest.json \
              > manifest.json.tmp && mv manifest.json.tmp manifest.json
            echo "Updated manifest with new create_budibase_instance Lambda version: $SHORT_SHA"
          fi

          if "${{ needs.list-and-read.outputs.lambda_destroy_instance_changed }}"; then
            jq '.Latest.Python.destroy_budibase_instance = "'$SHORT_SHA'"' manifest.json \
              > manifest.json.tmp && mv manifest.json.tmp manifest.json
            echo "Updated manifest with new destroy_budibase_instance Lambda version: $SHORT_SHA"
          fi         

          echo "Uploading updated manifest with ID $SHORT_SHA to S3..."
          aws s3 cp \
            --region "${{ vars.AWS_REGION }}" \
            manifest.json \
            "s3://${{ vars.MANIFEST_BUCKET }}/${SHORT_SHA}.json"
          echo "Manifest uploaded successfully."
      
      - name: Update manifest ID fallback tracking parameter
        if: ${{ steps.update-manifest.outcome == 'success' }}
        run: |
          SHORT_SHA="$(git rev-parse --short ${{ github.sha }})"

          echo "Updating SSM parameter ${{ vars.SSM_PARAM_NAME_MANIFEST_ID }} with new manifest ID $SHORT_SHA..."
          aws ssm put-parameter \
            --region "${{ vars.AWS_REGION }}" \
            --name "${{ vars.SSM_PARAM_NAME_MANIFEST_ID }}" \
            --value "$SHORT_SHA" \
            --overwrite
          echo "SSM parameter updated successfully."
