name: Tender Hub CI Pipeline

on:
  pull_request:
    types: [ opened, synchronize, reopened, closed ]
    branches: [ main ]

jobs:
  terraform-test-and-deploy:
    runs-on: ubuntu-latest
    environment: stage
    concurrency:
      group: deploy-to-stage
    permissions: 
      deployments: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          # Ensure unshallow fetch to allow for merge-base checks
          fetch-depth: 0 

      - name: Check for intervening merges
        id: check-merges
        # Check for other merges only if this is a post-merge run
        if: ${{ github.event.pull_request.merged == true }}
        run: |
          TOTAL_REVS=$(git rev-list \
            --count ${{ github.event.pull_request.base.sha }}..${{ github.sha }})
          BRANCH_REVS=$(git rev-list \
            --count ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})

          if [ $TOTAL_REVS -gt $(( $BRANCH_REVS + 1 )) ]; then
            echo "other_merges=true" >> $GITHUB_OUTPUT
          else
            echo "other_merges=false" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        id: configure-aws
        # Continue only if this is a pre-merge run OR post-merge run with other merges
        if: |
          ${{ github.event.pull_request.merged == false ||
          steps.check-merges.outputs.other_merges == 'true' }}
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}

      - name: Set up Terraform
        if: ${{ steps.configure-aws.outcome == 'success' }}
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Create Terraform backend and env configuration
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: |
          # Create backend
          mkdir -p envs/stage
          cat > envs/stage/backend.hcl <<EOF
          bucket = "${{ vars.STATE_BUCKET }}"
          key    = "${{ vars.STATE_KEY }}"
          region = "${{ vars.AWS_REGION }}"
          EOF
          cat > envs/stage/terraform.tfvars <<EOF
          ENVIRONMENT = "stage"
          EOF
          
          # Create global .tfvars file
          # For REPO_NAME, sed strips "user-name/repo-name" to just "repo-name"
          cat > global.auto.tfvars <<EOF
          AWS_REGION         = "${{ vars.AWS_REGION }}"
          IAM_USER           = "${{ secrets.IAM_USER }}"
          REPO_NAME          = "$(echo "${{ github.repository }}" | sed -E "s/.+\///g")"
          PREFIX             = "${{ vars.PREFIX }}"
          CLIENT             = "${{ vars.CLIENT }}"
          PROJECT            = "${{ vars.PROJECT }}"
          BUDIBASE_IMAGE_URL = "${{ vars.BUDIBASE_IMAGE_URL }}"
          EOF
          

      - name: Initialize Terraform
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform init -reconfigure -backend-config="envs/stage/backend.hcl"

      - name: Validate Terraform configuration
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform validate

      - name: Format Terraform code
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform fmt -check

      - name: Use Terraform workspace
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: ./switch_env.sh stage

      - name: Terraform plan with check for changes
        id: terraform-plan
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: |
          set +e
          terraform plan \
            -detailed-exitcode \
            -out=tfplan \
            -var-file="envs/stage/terraform.tfvars" \
            -var="BUDIBASE_TASK_COUNT=1"
          exit_code=$?
          echo "Terraform plan exit code: $exit_code"
          set -e
          if [ $exit_code -eq 2 ]; then
            echo "Changes detected in Terraform configuration."
            echo "runapply=true" >> $GITHUB_OUTPUT
          elif [ $exit_code -eq 1 ]; then
            echo "Error during Terraform plan."
            exit 1
          else
            echo "No changes detected. Infrastructure is up-to-date."
          fi

      - name: Terraform apply
        id: terraform-apply
        working-directory: infra
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: |
          terraform apply tfplan
            echo "lb_url=\"$(terraform output -raw lb_url)\"" >> $GITHUB_OUTPUT

      - name: Clean up Terraform plan file
        working-directory: infra
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: rm -f tfplan

      - name: Post-apply validation
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: |
          echo "Running post-apply validation..."
          
          timeout 300s bash -s "${{ steps.terraform-apply.outputs.lb_url }}" << 'EOF'
            LB_URL="$1"

            start_time="$SECONDS"
            until curl -s "$LB_URL" > /dev/null; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for load balancer to become available at $LB_URL ...$timestamp"
              sleep 10
            done
            echo "Load balancer available at $LB_URL"

            start_time="$SECONDS"
            until curl -s "$LB_URL" | grep -q 'Redirecting to <a href="/builder">/builder</a>'; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for redirection to /builder at $LB_URL ...$timestamp"
              sleep 10
            done
            echo "Redirection to /builder confirmed at $LB_URL"

            start_time="$SECONDS"
            until curl -s "${LB_URL}builder" --compressed | grep title | grep -q Budibase; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for Budibase builder to be available at ${LB_URL}builder ...$timestamp"
              sleep 10
            done
            echo "Budibase builder is available at ${LB_URL}builder"
          EOF

      - name: Terraform destroy
        working-directory: infra
        if: |
          ${{ steps.configure-aws.outcome == 'success' &&
          steps.terraform-plan.outputs.runapply == 'true' && 
          always() }}
        run: terraform destroy -auto-approve -var-file="envs/stage/terraform.tfvars"
      
      - name: Report deployment status to GitHub
        if: success()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Fetch the deployment ID for this commit
          DEPLOYMENT_ID=$(gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/deployments?environment=stage&sha=${{ github.event.pull_request.head.sha}}" \
            --jq '.[0].id')

          if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "null" ]; then
            # Provided deployment ID isn't empty or null, post status "success"
            gh api \
              -X POST \
              -H "Accept: application/vnd.github+json" \
              "repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" \
              -f state='success' \
              -f environment='stage' \
              -f environment_url='https://github.com//${{ github.repository_owner }}/${{ github.repository }}/deployments/stage' \
              -f description='Deployment verified and ready for merge'
          else
            # Deployment ID is empty or null: alert the user and fail
            echo "No deployment found for commit ${{ github.sha }}"
            exit 1
          fi

  update-manifest:
    runs-on: ubuntu-latest
    environment: stage
    needs: terraform-test-and-deploy
    if: ${{ github.event.pull_request.merged == true }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}

      - name: List changes
        id: list-changes
        run: |
          # get list of changed files between branch base and current commit
          # '|| true' protects against error if repo copy is already unshallow
          git fetch --unshallow origin main "${{ github.event.pull_request.base.sha }}" || true
          echo "Fetching latest changes from ${{ github.event.pull_request.base.sha }} to compare with current branch..."
          CHANGES="$(git diff --name-only ${{ github.event.pull_request.base.sha }}...HEAD)"

          # extract top-level directories from changed files and get unique list
          CHANGES="$(echo "$CHANGES" | grep -o '^[^/]*/' | sort -u)"
          printf "Changes detected in the following directories:\n%s\n" "$CHANGES"

          # output key change values for use in later steps
          if echo "$CHANGES" | grep -q infra; then
            TERRAFORM_CHANGED=true
            echo "Terraform changes detected."
          else
            TERRAFORM_CHANGED=false
            echo "No changes detected to Terraform."
          fi
          echo "terraform_changed=$TERRAFORM_CHANGED" >> $GITHUB_OUTPUT
        
      - name: Read manifest
        id: read-manifest
        run: |
          SHORT_SHA="$(git rev-parse --short ${{ github.sha }})"
          MANIFEST_ID="$(git rev-parse --short "${{ github.event.pull_request.base.sha }}")"

          echo "Fetching manifest with ID $MANIFEST_ID from S3..."
          aws s3 cp \
            --region "${{ vars.AWS_REGION }}" \
            "s3://${{ vars.MANIFEST_BUCKET }}/${MANIFEST_ID}.json" \
            manifest.json
          echo "Manifest fetched successfully."
      
      - name: Update and re-upload manifest
        id: update-manifest
        if: ${{ steps.read-manifest.outcome == 'success' }}
        run: |
          SHORT_SHA="$(git rev-parse --short ${{ github.sha }})"

          if "${{ steps.list-changes.outputs.terraform_changed }}"; then
            jq '.Latest.Terraform = "'$SHORT_SHA'"' manifest.json > manifest.json.tmp \
              && mv manifest.json.tmp manifest.json
            echo "Updated manifest with new Terraform version: $SHORT_SHA"
          fi

          echo "Uploading updated manifest with ID $SHORT_SHA to S3..."
          aws s3 cp \
            --region "${{ vars.AWS_REGION }}" \
            manifest.json \
            "s3://${{ vars.MANIFEST_BUCKET }}/${SHORT_SHA}.json"
          echo "Manifest uploaded successfully."
      
      - name: Update manifest ID fallback tracking parameter
        if: ${{ steps.update-manifest.outcome == 'success' }}
        run: |
          SHORT_SHA="$(git rev-parse --short ${{ github.sha }})"

          echo "Updating SSM parameter ${{ vars.SSM_PARAM_NAME_MANIFEST_ID }} with new manifest ID $SHORT_SHA..."
          aws ssm put-parameter \
            --region "${{ vars.AWS_REGION }}" \
            --name "${{ vars.SSM_PARAM_NAME_MANIFEST_ID }}" \
            --value "$SHORT_SHA" \
            --overwrite
          echo "SSM parameter updated successfully."
