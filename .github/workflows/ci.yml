name: Tender Hub CI Pipeline

on:
  pull_request:
    types: [ opened, synchronize, reopened, closed ]
    branches: [ main ]

jobs:
  pre-checks:
    runs-on: ubuntu-latest
    environment: stage
    # Skip job on PRs closed without being merged
    if: |
      ${{ github.event.action != 'closed' ||
      github.event.pull_request.merged == true }}
    outputs:
      other_merges: ${{ steps.check-merges.outputs.other_merges }}

      terraform_changed: ${{ steps.list-changes.outputs.terraform_changed }}
      python_changes_exist: ${{ steps.list-changes.outputs.python_changes_exist }}

      lambda_create_instance_changed: ${{ steps.list-changes.outputs.lambda_create_instance_changed }}
      lambda_destroy_instance_changed: ${{ steps.list-changes.outputs.lambda_destroy_instance_changed }}

      short_sha_base: ${{ steps.manifest-and-shas.outputs.short_sha_base }}
      short_sha_branch_head: ${{ steps.manifest-and-shas.outputs.short_sha_branch_head }}
      short_sha_merge: ${{ steps.manifest-and-shas.outputs.short_sha_merge }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          # Ensure unshallow fetch to allow for merge-base checks
          fetch-depth: 0 

      - name: Configure AWS credentials
        id: configure-aws
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}

      - name: Fetch base manifest and generate SHAs
        id: manifest-and-shas
        run: |
          # Generate short SHAs
          SHORT_SHA_BASE="$(git rev-parse --short "${{ github.event.pull_request.base.sha }}")"
          SHORT_SHA_BRANCH_HEAD="$(git rev-parse --short "${{ github.event.pull_request.head.sha }}")"
          SHORT_SHA_MERGE="$(git rev-parse --short "${{ github.sha }}")"

          # Print SHAs to log for reference
          printf "Branch base SHA: %s\nBranch head SHA: %s\nCandidate/actual merge SHA: %s\n" \
            "$SHORT_SHA_BASE" "$SHORT_SHA_BRANCH_HEAD" "$SHORT_SHA_MERGE"

          # Try to fetch base manifest
          echo "Fetching manifest with id $SHORT_SHA_BASE from S3..."
          set +e
          aws s3 cp \
            --region "${{ vars.AWS_REGION }}" \
            "s3://${{ vars.MANIFEST_BUCKET }}/${SHORT_SHA_BASE}.json" \
            manifest.json
          EXIT_CODE="$?"
          set -e

          if [ $EXIT_CODE -eq 1 ]; then
            echo "Manifest not found. Falling back on SSM value..."
            SSM_MANIFEST_ID="$(
              aws ssm get-parameter \
                --region "${{ vars.AWS_REGION }}" \
                --name "${{ vars.SSM_PARAM_NAME_MANIFEST_ID }}" \
                | jq -r '.Parameter.Value'
            )"
            echo "Fetching manifest with id $SSM_MANIFEST_ID from S3..."
            aws s3 cp \
              --region "${{ vars.AWS_REGION }}" \
              "s3://${{ vars.MANIFEST_BUCKET }}/${SSM_MANIFEST_ID}.json" \
              manifest.json
            echo "Manifest fetched successfully. Checks will continue with amended" \
              "base sha $SHORT_SHA_BASE." 

            echo "Manifest fetched successfully."

            # Update our working base SHA to whichever is older
            if git merge-base --is-ancestor "$SSM_MANIFEST_ID" "$SHORT_SHA_BASE"; then
              echo "SSM's $SSM_MANIFEST_ID is an ancestor of branch base $SHORT_SHA_BASE." \
                "Checks will continue with amended base SHA $SSM_MANIFEST_ID."
              SHORT_SHA_BASE="$SSM_MANIFEST_ID"
            else
              echo "Branch base $SHORT_SHA_BASE is an ancestor of SSM's $SSM_MANIFEST_ID." \
                "Checks will continue with existing base SHA."
          else
            echo "Manifest fetched successfully."
          fi

          # Output final SHAs for use throughout workflow
          echo "short_sha_base=$SHORT_SHA_BASE" >> $GITHUB_OUTPUT
          echo "short_sha_branch_head=$SHORT_SHA_BRANCH_HEAD" >> $GITHUB_OUTPUT
          echo "short_sha_merge=$SHORT_SHA_MERGE" >> $GITHUB_OUTPUT

      - name: Upload manifest artefact
        uses: actions/upload-artifact@v4
        with:
          name: base-manifest-${{ github.run_id }}
          path: manifest.json
          if-no-files-found: error
          retention-days: 1

      - name: Check for intervening merges
        id: check-merges
        # Check for other merges only if this is a post-merge run
        if: ${{ github.event.pull_request.merged == true }}
        run: |
          SHORT_SHA_BASE="${{ steps.manifest-and-shas.outputs.short_sha_base }}"
          TOTAL_REVS=$(git rev-list \
            --count $SHORT_SHA_BASE..${{ github.sha }})
          BRANCH_REVS=$(git rev-list \
            --count $SHORT_SHA_BASE..${{ github.event.pull_request.head.sha }})

          if [ $TOTAL_REVS -gt $(( $BRANCH_REVS + 1 )) ]; then
            echo "other_merges=true" >> $GITHUB_OUTPUT
          else
            echo "other_merges=false" >> $GITHUB_OUTPUT
          fi

      - name: List changes
        id: list-changes
        # Continue only if this is a pre-merge run OR post-merge run with other merges
        if: |
          ${{ github.event.pull_request.merged == false ||
          steps.check-merges.outputs.other_merges == 'true' }}
        run: |
          # get list of changed files between branch base (or fallback manifest) and current commit
          SHORT_SHA_BASE="${{ steps.manifest-and-shas.outputs.short_sha_base }}"
          git fetch origin main "$SHORT_SHA_BASE"
          echo "Fetching latest changes from $SHORT_SHA_BASE" \
            "to compare with current branch..."
          CHANGES="$(git diff --name-only "$SHORT_SHA_BASE"...HEAD)"

          # extract top-level directories from changed files and get unique list
          CHANGED_DIRS="$(echo "$CHANGES" | grep -o '^[^/]*/' | sort -u)"
          printf "Changes detected in the following directories:\n%s\n" "$CHANGED_DIRS"

          
          # output key change values for use in later steps
          if echo "$CHANGED_DIRS" | grep -q "infra"; then
            TERRAFORM_CHANGED=true
            echo "Terraform changes detected."
          else
            TERRAFORM_CHANGED=false
            echo "No changes detected to Terraform."
          fi
          
          if echo "$CHANGED_DIRS" | grep -q "src"; then
            PYTHON_CHANGES_EXIST=true
            echo "Changes to Python code detected."
            
            # extract Python files under src/ directory from changed list
            CHANGED_PYTHON="$(echo "$CHANGES" | grep '^src/.*.py' | xargs -L 1 basename)"

            if echo "$CHANGED_PYTHON" | grep -q "create_budibase_instance.py"; then
              LAMBDA_CREATE_INSTANCE_CHANGED=true
              echo "Lambda function create_budibase_instance changed."
            else
              LAMBDA_CREATE_INSTANCE_CHANGED=false
            fi

            if echo "$CHANGED_PYTHON" | grep -q "destroy_budibase_instance.py"; then
              LAMBDA_DESTROY_INSTANCE_CHANGED=true
              echo "Lambda function destroy_budibase_instance changed."
            else
              LAMBDA_DESTROY_INSTANCE_CHANGED=false
            fi
          else
            PYTHON_CHANGES_EXIST=false
            echo "No changes detected to Python code."
          fi
          
          echo "terraform_changed=$TERRAFORM_CHANGED" >> $GITHUB_OUTPUT
          echo "python_changes_exist=$PYTHON_CHANGES_EXIST" >> $GITHUB_OUTPUT
          echo "lambda_create_instance_changed=$LAMBDA_CREATE_INSTANCE_CHANGED" \
            >> $GITHUB_OUTPUT
          echo "lambda_destroy_instance_changed=$LAMBDA_DESTROY_INSTANCE_CHANGED" \
            >> $GITHUB_OUTPUT

  python-test-and-deploy:
    runs-on: ubuntu-latest
    environment: stage
    needs: pre-checks
    if: ${{ needs.pre-checks.outputs.python_changes_exist == 'true' }}
    outputs:
      upload_artefacts_outcome: ${{ steps.upload-code-artefacts.outcome }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Check linting with ruff
        uses: astral-sh/ruff-action@v3
        with:
          src: >-
            ./src
            ./test

      - name: Check formatting with ruff
        run: ruff format --check

      - name: Run unit tests
        run: echo "TK"
      
      - name: Configure AWS credentials
        id: configure-aws
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}

      - name: Upload changed code artefacts to S3
        id: upload-code-artefacts
        run: |
          # Ensure errors occurring in 'if' blocks are propagated
          set -e

          if [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
            SHORT_SHA_CODE="${{ needs.pre-checks.outputs.short_sha_merge }}"
          else
            SHORT_SHA_CODE="${{ needs.pre-checks.outputs.short_sha_branch_head }}"
          fi

          if [[ "${{ needs.pre-checks.outputs.lambda_create_instance_changed }}" == "true" ]]; then
            mkdir -p packages/lambdas/
            zip -j packages/lambdas/create_budibase_instance.zip src/create_budibase_instance.py
            aws s3 cp packages/lambdas/create_budibase_instance.zip \
              s3://${{ vars.CODE_BUCKET }}/create_budibase_instance/$SHORT_SHA_CODE.zip
          fi

          if [[ "${{ needs.pre-checks.outputs.lambda_destroy_instance_changed }}" == "true" ]]; then
            mkdir -p packages/lambdas/
            zip -j packages/lambdas/destroy_budibase_instance.zip src/destroy_budibase_instance.py
            aws s3 cp packages/lambdas/destroy_budibase_instance.zip \
              s3://${{ vars.CODE_BUCKET }}/destroy_budibase_instance/$SHORT_SHA_CODE.zip
          fi

  terraform-test-and-deploy:
    runs-on: ubuntu-latest
    environment: stage
    concurrency:
      group: deploy-to-stage
    permissions: 
      deployments: write
    needs: [
      pre-checks,
      python-test-and-deploy
    ]
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          # Ensure unshallow fetch to allow for merge-base checks
          fetch-depth: 0 

      - name: Check for intervening merges
        id: check-merges
        # Check for other merges only if this is a post-merge run
        if: ${{ github.event.pull_request.merged == true }}
        run: |
          TOTAL_REVS=$(git rev-list \
            --count ${{ github.event.pull_request.base.sha }}..${{ github.sha }})
          BRANCH_REVS=$(git rev-list \
            --count ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})

          if [ $TOTAL_REVS -gt $(( $BRANCH_REVS + 1 )) ]; then
            echo "other_merges=true" >> $GITHUB_OUTPUT
          else
            echo "other_merges=false" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        id: configure-aws
        # Continue only if this is a pre-merge run OR post-merge run with other merges
        if: |
          ${{ github.event.pull_request.merged == false ||
          steps.check-merges.outputs.other_merges == 'true' }}
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}

      - name: Set up Terraform
        if: ${{ steps.configure-aws.outcome == 'success' }}
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Download manifest artifact
        id: download-manifest
        uses: actions/download-artifact@v5
        with:
          name: base-manifest-${{ github.run_id }}

      - name: Create Terraform backend and env configuration
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: |
          # Determine Lambda code versions for deployment

          if [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
            SHORT_SHA_CODE="${{ needs.pre-checks.outputs.short_sha_merge }}"
          else
            SHORT_SHA_CODE="${{ needs.pre-checks.outputs.short_sha_branch_head }}"
          fi

          if [[ "${{ needs.pre-checks.outputs.lambda_create_instance_changed }}" == "true" ]]; then
            LAMBDA_CREATE_SERVICE_VERSION="$SHORT_SHA_CODE"
          else
            LAMBDA_CREATE_SERVICE_VERSION="$(
              jq -r '.Latest.Python.create_budibase_instance' ../manifest.json
            )"
          fi

          if [[ "${{ needs.pre-checks.outputs.lambda_destroy_instance_changed }}" == "true" ]]; then
            LAMBDA_DESTROY_SERVICE_VERSION="$SHORT_SHA_CODE"
          else
            LAMBDA_DESTROY_SERVICE_VERSION="$(
              jq -r '.Latest.Python.destroy_budibase_instance' ../manifest.json
            )"
          fi

          # Create backend 
          
          mkdir -p envs/stage
          cat > envs/stage/backend.hcl <<EOF
          region      = "${{ vars.AWS_REGION }}"
          bucket      = "${{ vars.STATE_BUCKET }}"
          key         = "${{ vars.STATE_KEY }}"
          EOF

          cat > envs/stage/terraform.tfvars <<EOF
          ENVIRONMENT = "stage"
          CODE_BUCKET = "${{ vars.CODE_BUCKET }}"

          LAMBDA_CREATE_SERVICE_VERSION  = "$LAMBDA_CREATE_SERVICE_VERSION"
          LAMBDA_DESTROY_SERVICE_VERSION = "$LAMBDA_DESTROY_SERVICE_VERSION" 
          EOF
          
          # Create global .tfvars file
          # For REPO_NAME, sed strips "user-name/repo-name" to just "repo-name"

          cat > global.auto.tfvars <<EOF
          AWS_REGION         = "${{ vars.AWS_REGION }}"
          IAM_USER           = "${{ secrets.IAM_USER }}"
          REPO_NAME          = "$(echo "${{ github.repository }}" | sed -E "s/.+\///g")"
          PREFIX             = "${{ vars.PREFIX }}"
          CLIENT             = "${{ vars.CLIENT }}"
          PROJECT            = "${{ vars.PROJECT }}"
          BUDIBASE_IMAGE_URL = "${{ vars.BUDIBASE_IMAGE_URL }}"
          EOF

      - name: Initialize Terraform
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform init -reconfigure -backend-config="envs/stage/backend.hcl"

      - name: Validate Terraform configuration
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform validate

      - name: Format Terraform code
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: terraform fmt -check

      - name: Use Terraform workspace
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: ./switch_env.sh stage

      - name: Terraform plan with check for changes
        id: terraform-plan
        working-directory: infra
        if: ${{ steps.configure-aws.outcome == 'success' }}
        run: |
          set +e
          terraform plan \
            -detailed-exitcode \
            -out=tfplan \
            -var-file="envs/stage/terraform.tfvars" \
            -var="BUDIBASE_TASK_COUNT=1"
          EXIT_CODE="$?"
          set -e

          if [ $EXIT_CODE -eq 2 ]; then
            echo "Changes detected in Terraform configuration."
            echo "runapply=true" >> $GITHUB_OUTPUT
          elif [ $EXIT_CODE -eq 1 ]; then
            echo "Error during Terraform plan."
            exit 1
          else
            echo "No changes detected. Infrastructure is up-to-date."
          fi

      - name: Terraform apply
        id: terraform-apply
        working-directory: infra
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: |
          terraform apply tfplan
            echo "lb_url=\"$(terraform output -raw lb_url)\"" >> $GITHUB_OUTPUT

      - name: Clean up Terraform plan file
        working-directory: infra
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: rm -f tfplan

      - name: Post-apply validation
        if: ${{ steps.terraform-plan.outputs.runapply == 'true' }}
        run: |
          echo "Running post-apply validation..."
          
          timeout 300s bash -s "${{ steps.terraform-apply.outputs.lb_url }}" << 'EOF'
            LB_URL="$1"

            start_time="$SECONDS"
            until curl -s "$LB_URL" > /dev/null; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for load balancer to become available at $LB_URL ...$timestamp"
              sleep 10
            done
            echo "Load balancer available at $LB_URL"

            start_time="$SECONDS"
            until curl -s "$LB_URL" | grep -q 'Redirecting to <a href="/builder">/builder</a>'; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for redirection to /builder at $LB_URL ...$timestamp"
              sleep 10
            done
            echo "Redirection to /builder confirmed at $LB_URL"

            start_time="$SECONDS"
            until curl -s "${LB_URL}builder" --compressed | grep title | grep -q Budibase; do
              elapsed="$(( SECONDS - start_time ))"
              timestamp=""
              if [ "$elapsed" -ge 10 ]; then
                timestamp=" [$(date -u --date="@$elapsed" +%Mm%Ss) elapsed]"
              fi
              echo "Waiting for Budibase builder to be available at ${LB_URL}builder ...$timestamp"
              sleep 10
            done
            echo "Budibase builder is available at ${LB_URL}builder"
          EOF

      - name: Terraform destroy
        working-directory: infra
        if: |
          ${{ steps.configure-aws.outcome == 'success' &&
          steps.terraform-plan.outputs.runapply == 'true' && 
          always() }}
        run: terraform destroy -auto-approve -var-file="envs/stage/terraform.tfvars"
      
      - name: Report deployment status to GitHub
        if: success()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Fetch the deployment ID for this commit
          DEPLOYMENT_ID=$(gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/deployments?environment=stage&sha=${{ github.event.pull_request.head.sha }}" \
            --jq '.[0].id')

          if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "null" ]; then
            # Provided deployment ID isn't empty or null, post status "success"
            gh api \
              -X POST \
              -H "Accept: application/vnd.github+json" \
              "repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" \
              -f state='success' \
              -f environment='stage' \
              -f environment_url='https://github.com//${{ github.repository_owner }}/${{ github.repository }}/deployments/stage' \
              -f description='Deployment verified and ready for merge'
          else
            # Deployment ID is empty or null: alert the user and fail
            echo "No deployment found for commit ${{ github.event.pull_request.head.sha }}"
            exit 1
          fi

  artefact-cleanup:
    runs-on: ubuntu-latest
    environment: stage
    needs: [
      pre-checks,
      python-test-and-deploy,
      terraform-test-and-deploy
    ]
    if: |
      ${{ always() &&
          needs.python-test-and-deploy.outputs.upload_artefacts_outcome == 'success' &&
          ( needs.python-test-and-deploy.result == 'failure' ||
          needs.terraform-test-and-deploy.result == 'failure') }}
    steps:
      - name: Configure AWS credentials
        id: configure-aws
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}
      
      - name: Delete created artefacts
        run: |
          # Ensure errors occuring in 'if' blocks are propagated
          set -e
          
          if [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
            SHORT_SHA_CODE="${{ needs.pre-checks.outputs.short_sha_merge }}"
          else
            SHORT_SHA_CODE="${{ needs.pre-checks.outputs.short_sha_branch_head }}"
          fi

          if [[ "${{ needs.pre-checks.outputs.lambda_create_instance_changed }}" == "true" ]]; then
            aws s3 rm s3://${{ vars.CODE_BUCKET }}/create_budibase_instance/$SHORT_SHA_CODE.zip
            echo "Removed artefact /create_budibase_instance/$SHORT_SHA_CODE.zip"
          fi

          if [[ "${{ needs.pre-checks.outputs.lambda_destroy_instance_changed }}" == "true" ]]; then
            aws s3 rm s3://${{ vars.CODE_BUCKET }}/destroy_budibase_instance/$SHORT_SHA_CODE.zip
            echo "Removed artefact /destroy_budibase_instance/$SHORT_SHA_CODE.zip"
          fi

  update-manifest:
    runs-on: ubuntu-latest
    environment: stage
    needs: [
      pre-checks,
      python-test-and-deploy,
      terraform-test-and-deploy
    ]
    if: ${{ github.event.pull_request.merged == true }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v6.0.0
        with:
          aws-access-key-id:
            ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key:
            ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:
            ${{ vars.AWS_REGION }}

      - name: Download manifest artifact
        id: download-manifest
        uses: actions/download-artifact@v5
        with:
          name: base-manifest-${{ github.run_id }}

      - name: Generate and upload manifest
        id: update-manifest
        if: ${{ steps.download-manifest.outcome == 'success' }}
        run: |
          # Ensure errors occurring in 'if' blocks are propagated
          set -e

          SHORT_SHA_MERGE="${{ needs.pre-checks.outputs.short_sha_merge }}"

          SHORT_SHA_TF="$SHORT_SHA_MERGE"

          if [[ "${{ github.event.pull_request.merged }}" == "true" ]]; then
            SHORT_SHA_CODE="$SHORT_SHA_MERGE"
          else
            SHORT_SHA_CODE="${{ needs.pre-checks.outputs.short_sha_branch_head }}"
          fi

          if [[ "${{ needs.pre-checks.outputs.terraform_changed }}" == "true" ]]; then
            jq '.Latest.Terraform = "'$SHORT_SHA_TF'"' manifest.json \
              > manifest.json.tmp && mv manifest.json.tmp manifest.json
            echo "Updated manifest with new Terraform version: $SHORT_SHA_TF"
          fi

          if [[ "${{ needs.pre-checks.outputs.lambda_create_instance_changed }}" == "true" ]]; then
            jq '.Latest.Python.create_budibase_instance = "'$SHORT_SHA_CODE'"' manifest.json \
              > manifest.json.tmp && mv manifest.json.tmp manifest.json
            echo "Updated manifest with new create_budibase_instance Lambda version: $SHORT_SHA_CODE"
          fi

          if [[ "${{ needs.pre-checks.outputs.lambda_destroy_instance_changed }}" == "true" ]]; then
            jq '.Latest.Python.destroy_budibase_instance = "'$SHORT_SHA_CODE'"' manifest.json \
              > manifest.json.tmp && mv manifest.json.tmp manifest.json
            echo "Updated manifest with new destroy_budibase_instance Lambda version: $SHORT_SHA_CODE"
          fi         

          echo "Uploading updated manifest with ID $SHORT_SHA_MERGE to S3..."
          aws s3 cp \
            --region "${{ vars.AWS_REGION }}" \
            manifest.json \
            "s3://${{ vars.MANIFEST_BUCKET }}/${SHORT_SHA_MERGE}.json"
          echo "Manifest uploaded successfully."
      
      - name: Update manifest ID fallback tracking parameter
        if: ${{ steps.update-manifest.outcome == 'success' }}
        run: |
          SHORT_SHA="${{ needs.pre-checks.outputs.short_sha_merge }}"

          echo "Updating SSM parameter ${{ vars.SSM_PARAM_NAME_MANIFEST_ID }} with new manifest ID $SHORT_SHA..."
          aws ssm put-parameter \
            --region "${{ vars.AWS_REGION }}" \
            --name "${{ vars.SSM_PARAM_NAME_MANIFEST_ID }}" \
            --value "$SHORT_SHA" \
            --overwrite
          echo "SSM parameter updated successfully."
